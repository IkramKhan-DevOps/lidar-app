import UIKit
import ARKit
import SceneKit
import AVFoundation
import os.log

@available(iOS 13.4, *)
class ScanViewController: UIViewController {
    
    // MARK: - Components
    private let arScanner = ARScanner()
    let captureManager = ScanCaptureManager() // Changed from private to internal
    private let controlPanel = ControlPanel()
    private let fileManager = FileManager.default
    
    // MARK: - Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        setupDelegates()
        checkCameraPermission()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        arScanner.stopScan()
        cleanupTemporaryFiles()
    }
    
    // MARK: - Setup
    private func setupUI() {
        view.backgroundColor = .black
        
        // Add AR View
        view.addSubview(arScanner.view)
        arScanner.view.frame = view.bounds
        
        // Add Control Panel
        view.addSubview(controlPanel)
        controlPanel.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            controlPanel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            controlPanel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            controlPanel.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20)
        ])
    }
    
    private func setupDelegates() {
        arScanner.delegate = self
        controlPanel.delegate = self
    }
    
    // MARK: - Permission Handling
    private func checkCameraPermission() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized:
            controlPanel.updateUIForScanningState(isScanning: false, hasMeshes: false)
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
                DispatchQueue.main.async {
                    if granted {
                        self?.controlPanel.updateUIForScanningState(isScanning: false, hasMeshes: false)
                    } else {
                        self?.showAlert(title: "Permission Denied",
                                      message: "Camera access is required for AR scanning.")
                    }
                }
            }
        default:
            showAlert(title: "Permission Denied",
                     message: "Camera access is required for AR scanning.")
        }
    }
    
    // MARK: - Data Management
    private func saveCapturedMeshes() throws -> URL {
        let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileURL = documentsURL.appendingPathComponent("scan_\(Date().timeIntervalSince1970).json")
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(arScanner.getCapturedMeshes())
        try data.write(to: fileURL)
        
        return fileURL
    }
    
    private func generatePLYContent() throws -> String {
        let meshes = arScanner.getCapturedMeshes()
        guard !meshes.isEmpty else {
            throw NSError(domain: "No meshes", code: 0, userInfo: nil)
        }
        
        var plyHeader = """
        ply
        format ascii 1.0
        comment Generated by ARScanner
        element vertex \(meshes.reduce(0) { $0 + $1.vertices.count })
        property float x
        property float y
        property float z
        element face \(meshes.reduce(0) { $0 + $1.indices.count / 3 })
        property list uchar uint vertex_indices
        end_header\n\n
        """
        
        var vertexOffset = 0
        var plyBody = ""
        
        // Write vertices
        for mesh in meshes {
            for vertex in mesh.vertices {
                plyBody += "\(vertex.x) \(vertex.y) \(vertex.z)\n"
            }
        }
        
        // Write faces
        for mesh in meshes {
            for i in stride(from: 0, to: mesh.indices.count, by: 3) {
                let i0 = mesh.indices[i] + UInt32(vertexOffset)
                let i1 = mesh.indices[i+1] + UInt32(vertexOffset)
                let i2 = mesh.indices[i+2] + UInt32(vertexOffset)
                plyBody += "3 \(i0) \(i1) \(i2)\n"
            }
            vertexOffset += mesh.vertices.count
        }
        
        return plyHeader + plyBody
    }
    
    private func savePLYFile(content: String) throws -> URL {
        let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileURL = documentsURL.appendingPathComponent("scan_\(Date().timeIntervalSince1970).ply")
        try content.write(to: fileURL, atomically: true, encoding: .utf8)
        return fileURL
    }
    
    private func shareFile(_ fileURL: URL) {
        let activityVC = UIActivityViewController(activityItems: [fileURL],
                                                applicationActivities: nil)
        activityVC.popoverPresentationController?.sourceView = controlPanel.exportButton
        activityVC.popoverPresentationController?.sourceRect = controlPanel.exportButton.bounds
        present(activityVC, animated: true)
    }
    
    // MARK: - File Cleanup
    private func cleanupTemporaryFiles() {
        DispatchQueue.global(qos: .utility).async { [weak self] in
            self?.captureManager.cleanupCaptureDirectory()
            os_log("Cleaned up temporary capture files", log: OSLog.default, type: .info)
        }
    }
    
    private func cleanupAfterExport() {
        DispatchQueue.global(qos: .utility).async { [weak self] in
            self?.captureManager.cleanupCaptureDirectory()
            os_log("Cleaned up files after successful export", log: OSLog.default, type: .info)
        }
    }
    
    // MARK: - UI Helpers
    private func showAlert(title: String, message: String) {
        let alert = UIAlertController(title: title,
                                    message: message,
                                    preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default))
        present(alert, animated: true)
    }
    
    private func showPreview() {
        let previewVC = ModelViewController()
        previewVC.capturedMeshes = arScanner.getCapturedMeshes()
        previewVC.modalPresentationStyle = .fullScreen
        present(previewVC, animated: true)
    }
}

// MARK: - ARScannerDelegate
@available(iOS 13.4, *)
extension ScanViewController: ARScannerDelegate {
    func arScanner(_ scanner: ARScanner, didUpdateStatus status: String) {
        DispatchQueue.main.async {
            self.controlPanel.updateStatus(status)
        }
    }
    
    func arScanner(_ scanner: ARScanner, didUpdateMeshesCount count: Int) {
        DispatchQueue.main.async {
            self.controlPanel.updateUIForScanningState(isScanning: scanner.isScanning,
                                                      hasMeshes: count > 0)
        }
    }
    
    func arScannerDidStopScanning(_ scanner: ARScanner) {
        DispatchQueue.main.async {
            self.controlPanel.updateUIForScanningState(isScanning: false,
                                                     hasMeshes: !scanner.getCapturedMeshes().isEmpty)
        }
        cleanupTemporaryFiles()
    }
    
    func arScannerDidStartScanning(_ scanner: ARScanner) {
        DispatchQueue.main.async {
            self.controlPanel.updateUIForScanningState(isScanning: true, hasMeshes: false)
        }
    }
    
    func arScanner(_ scanner: ARScanner, showAlertWithTitle title: String, message: String) {
        showAlert(title: title, message: message)
    }
}

// MARK: - ControlPanelDelegate
@available(iOS 13.4, *)
extension ScanViewController: ControlPanelDelegate {
    func controlPanelDidTapStart(_ panel: ControlPanel) {
        arScanner.startScan()
    }
    
    func controlPanelDidTapStop(_ panel: ControlPanel) {
        arScanner.stopScan()
    }
    
    func controlPanelDidTapRestart(_ panel: ControlPanel) {
        arScanner.restartScan()
        cleanupTemporaryFiles()
    }
    
    func controlPanelDidTapPreview(_ panel: ControlPanel) {
        showPreview()
    }
    
    func controlPanel(_ panel: ControlPanel, didRequestExportAs format: ExportFormat) {
        switch format {
        case .json:
            exportAsJSON()
        case .ply:
            exportAsPLY()
        }
    }
    
    private func exportAsJSON() {
        do {
            let fileURL = try saveCapturedMeshes()
            shareFile(fileURL)
            cleanupAfterExport()
        } catch {
            showAlert(title: "Export Error",
                     message: error.localizedDescription)
        }
    }
    
    private func exportAsPLY() {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            
            do {
                let plyContent = try self.generatePLYContent()
                let fileURL = try self.savePLYFile(content: plyContent)
                
                DispatchQueue.main.async {
                    self.shareFile(fileURL)
                    self.cleanupAfterExport()
                }
            } catch {
                DispatchQueue.main.async {
                    self.showAlert(title: "Export Error",
                                 message: error.localizedDescription)
                }
            }
        }
    }
}
